[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"
  flush_jitter = "0s"

# Collecte MQTT avec support des deux formats (normal et compact)
[[inputs.mqtt_consumer]]
  servers = ["tcp://mosquitto:1883"]
  topics = ["sensors/+/+"]
  username = "mqtt_user"
  password = "mqtt_password"
  data_format = "json"
  
  # Champs string pour format normal et compact
  json_string_fields = [
    # Format normal
    "device_id", "sensor_type", "location", "measurement_type",
    "ucum.code", "ucum.display", "ucum.common_name", "ucum.quantity_type",
    # Format compact
    "id", "type", "loc", "unit", "sym"
  ]
  
  # Tags pour indexation - support dual format
  tag_keys = [
    # Format normal
    "device_id", "sensor_type", "location", "ucum.code", "ucum.quantity_type",
    # Format compact  
    "id", "type", "loc", "unit"
  ]

# Processor de normalisation des formats
[[processors.regex]]
  # Normalisation device_id
  [[processors.regex.tags]]
    key = "id"
    pattern = "^(.+)$"
    replacement = "${1}"
    result_key = "device_id"
  
  # Normalisation sensor_type
  [[processors.regex.tags]]
    key = "type"
    pattern = "^(.+)$"
    replacement = "${1}"
    result_key = "sensor_type"
  
  # Normalisation location
  [[processors.regex.tags]]
    key = "loc"
    pattern = "^(.+)$"
    replacement = "${1}"
    result_key = "location"
  
  # Normalisation code UCUM
  [[processors.regex.tags]]
    key = "unit"
    pattern = "^(.+)$"
    replacement = "${1}"
    result_key = "ucum.code"

# Processor pour normaliser les champs de valeur
[[processors.regex]]
  # Normalisation de la valeur (compact -> normal)
  [[processors.regex.fields]]
    key = "val"
    pattern = "^(.+)$"
    replacement = "${1}"
    result_key = "value"

# Processor pour enrichir avec métadonnées UCUM manquantes
[[processors.starlark]]
  script = '''
def apply(metric):
    # Si format compact, ajouter les métadonnées UCUM manquantes
    if "unit" in metric.tags and "ucum.code" not in metric.tags:
        ucum_code = metric.tags.get("unit", "")
        metric.tags["ucum.code"] = ucum_code
        
        # Mapping des symboles d'affichage
        symbol_map = {
            "Cel": "°C",
            "%": "%",
            "hPa": "hPa", 
            "lx": "lx"
        }
        metric.tags["ucum.display"] = symbol_map.get(ucum_code, ucum_code)
        
        # Mapping des types de quantité
        quantity_map = {
            "Cel": "thermodynamic-temperature",
            "%": "dimensionless-ratio",
            "hPa": "pressure",
            "lx": "illuminance"
        }
        metric.tags["ucum.quantity_type"] = quantity_map.get(ucum_code, "unknown")
    
    # Normalisation device_id/id
    if "id" in metric.tags and "device_id" not in metric.tags:
        metric.tags["device_id"] = metric.tags["id"]
    
    # Normalisation sensor_type/type
    if "type" in metric.tags and "sensor_type" not in metric.tags:
        metric.tags["sensor_type"] = metric.tags["type"]
    
    # Normalisation value/val
    if "val" in metric.fields and "value" not in metric.fields:
        metric.fields["value"] = metric.fields["val"]
    
    # Conversions vers unités SI
    ucum_code = metric.tags.get("ucum.code", "")
    value = metric.fields.get("value", 0.0)
    
    if ucum_code == "Cel":
        metric.fields["value_si"] = value + 273.15
        metric.tags["si_unit"] = "K"
    elif ucum_code == "[degF]":
        metric.fields["value_si"] = (value - 32) * 5/9 + 273.15
        metric.tags["si_unit"] = "K"
    elif ucum_code == "hPa":
        metric.fields["value_si"] = value * 100
        metric.tags["si_unit"] = "Pa"
    else:
        metric.fields["value_si"] = value
        metric.tags["si_unit"] = ucum_code
    
    return metric
'''

# Sortie vers InfluxDB
[[outputs.influxdb_v2]]
  urls = ["http://influxdb:8086"]
  token = "my-super-secret-auth-token"
  organization = "iot-sensors"
  bucket = "sensor-data"
  timeout = "5s"
  user_agent = "telegraf-iot-sensors-ucum"
